<!DOCTYPE html>
<html>
<head>
<title>Test toon shading</title>
<meta charset="utf-8">
<style>
body {
	color: #111111;
	font-family: Monospace;
	font-size: 13px;
	text-align: center;
	font-weight: bold;
	background-color: #ffffff;
	margin: 0px;
	overflow: hidden;
}

#info {
	position: absolute;
	top: 0px;
	width: 100%;
	padding: 5px;
}

a {
	color: #ee0000;
}
</style>
</head>
<body>
	ToonShading test
	<script src="js/core/three.js"></script>
	<script src="js/core/ShaderToon.js"></script>
	<script src="js/core/ShaderPass.js"></script>
	<script>
		var camera, scene, renderer;
		var object, light;

		var hatchingEffect, outineEffect;
		var outlineMesh, innerMesh;

		init();
		animate();

		function init() {

			renderer = new THREE.WebGLRenderer({
				clearAlpha : 1,
				clearColor : 0xffffff
			});
			renderer.setSize(window.innerWidth, window.innerHeight);

			document.body.appendChild(renderer.domElement);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
			camera.position.set(0, 10, 200);

			scene = new THREE.Scene();
			object = new THREE.Object3D();
			scene.add(object);

			scene.add(new THREE.AmbientLight(0xaaaaaa));

			light = new THREE.DirectionalLight(0x111111);
			light.position.x = 1;
			light.position.y = 1;
			light.position.z = 1;
			scene.add(light);

			// postprocessing
			// hatching 
			hatchingEffect = new THREE.ShaderPass(THREE.ShaderToon['hatching']);

			hatchingEffect.uniforms.uDirLightPos.value = light.position;
			hatchingEffect.uniforms.uDirLightColor.value = light.color;

			var u = THREE.UniformsUtils.clone(hatchingEffect.uniforms);
			var vs = hatchingEffect.material.vertexShader;
			var fs = hatchingEffect.material.fragmentShader;

			var hatching = new THREE.ShaderMaterial({
				uniforms : u,
				vertexShader : vs,
				fragmentShader : fs
			});

			// outline 
			outlineEffect = new THREE.ShaderPass(THREE.ShaderToon['outline']);
			var u = THREE.UniformsUtils.clone(outlineEffect.uniforms);
			var vs = outlineEffect.material.vertexShader;
			var fs = outlineEffect.material.fragmentShader;

			var outline = new THREE.ShaderMaterial({
				uniforms : u,
				vertexShader : vs,
				fragmentShader : fs
			});
			outline.uniforms.linewidth.value = 0.3;

			var loader = new THREE.JSONLoader();
			var callback = function(geometry, materials) {
				createScene(geometry, materials, 90, 10, 50, 105)
			};
			loader.load("models/stickman/stickman.js", callback);

			window.addEventListener('resize', onWindowResize, false);
		}

		function createScene(geometry, materials, x, y, z, b) {

			zmesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
			zmesh.position.set(x, y, z);
			zmesh.scale.set(3, 3, 3);
			scene.add(zmesh);

			createMaterialsPalette(materials, 100, b);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);

			object.rotation.y += 0.01;
			object.rotation.x += 0.02;

			//composer.render();
			renderer.render(scene, camera);

		}
	</script>
</body>
</html>
